// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteUserWatchlist = `-- name: DeleteUserWatchlist :exec
UPDATE "user" 
SET watchlist = NULL
WHERE email = $1
`

func (q *Queries) DeleteUserWatchlist(ctx context.Context, email string) error {
	_, err := q.db.Exec(ctx, deleteUserWatchlist, email)
	return err
}

const getAllUsers = `-- name: GetAllUsers :many
SELECT email, letterboxd_username FROM "user"
`

type GetAllUsersRow struct {
	Email              string `json:"email"`
	LetterboxdUsername string `json:"letterboxd_username"`
}

func (q *Queries) GetAllUsers(ctx context.Context) ([]GetAllUsersRow, error) {
	rows, err := q.db.Query(ctx, getAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllUsersRow{}
	for rows.Next() {
		var i GetAllUsersRow
		if err := rows.Scan(&i.Email, &i.LetterboxdUsername); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchingFilmEventsByEmail = `-- name: GetMatchingFilmEventsByEmail :many
SELECT fe.name, fe.url, fe.start_date, fe.end_date,
       fe.location_name, fe.location_address,
       fe.organizer_name, fe.organizer_url, fe.performer_name
FROM film_event AS fe
INNER JOIN "user" AS u ON fe.name = u.film_title
WHERE u.email = $1
`

type GetMatchingFilmEventsByEmailRow struct {
	Name            string             `json:"name"`
	Url             string             `json:"url"`
	StartDate       pgtype.Timestamptz `json:"start_date"`
	EndDate         pgtype.Timestamptz `json:"end_date"`
	LocationName    string             `json:"location_name"`
	LocationAddress string             `json:"location_address"`
	OrganizerName   string             `json:"organizer_name"`
	OrganizerUrl    string             `json:"organizer_url"`
	PerformerName   string             `json:"performer_name"`
}

func (q *Queries) GetMatchingFilmEventsByEmail(ctx context.Context, email string) ([]GetMatchingFilmEventsByEmailRow, error) {
	rows, err := q.db.Query(ctx, getMatchingFilmEventsByEmail, email)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMatchingFilmEventsByEmailRow{}
	for rows.Next() {
		var i GetMatchingFilmEventsByEmailRow
		if err := rows.Scan(
			&i.Name,
			&i.Url,
			&i.StartDate,
			&i.EndDate,
			&i.LocationName,
			&i.LocationAddress,
			&i.OrganizerName,
			&i.OrganizerUrl,
			&i.PerformerName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserIDByEmail = `-- name: GetUserIDByEmail :one
SELECT id FROM "user" WHERE email = $1
`

func (q *Queries) GetUserIDByEmail(ctx context.Context, email string) (int64, error) {
	row := q.db.QueryRow(ctx, getUserIDByEmail, email)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getUserIDByToken = `-- name: GetUserIDByToken :one
SELECT id FROM "user" WHERE token = $1
`

func (q *Queries) GetUserIDByToken(ctx context.Context, token string) (int64, error) {
	row := q.db.QueryRow(ctx, getUserIDByToken, token)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getUserWatchlist = `-- name: GetUserWatchlist :one
SELECT watchlist FROM "user" WHERE email = $1
`

func (q *Queries) GetUserWatchlist(ctx context.Context, email string) ([]string, error) {
	row := q.db.QueryRow(ctx, getUserWatchlist, email)
	var watchlist []string
	err := row.Scan(&watchlist)
	return watchlist, err
}

const insertFilmEvent = `-- name: InsertFilmEvent :exec
INSERT INTO "film_event" (
    name, url, start_date, end_date,
    location_name, location_address,
    organizer_name, organizer_url, performer_name
) VALUES (
    $1, $2, $3, $4,
    $5, $6, $7, $8, $9
)
`

type InsertFilmEventParams struct {
	Name            string             `json:"name"`
	Url             string             `json:"url"`
	StartDate       pgtype.Timestamptz `json:"start_date"`
	EndDate         pgtype.Timestamptz `json:"end_date"`
	LocationName    string             `json:"location_name"`
	LocationAddress string             `json:"location_address"`
	OrganizerName   string             `json:"organizer_name"`
	OrganizerUrl    string             `json:"organizer_url"`
	PerformerName   string             `json:"performer_name"`
}

func (q *Queries) InsertFilmEvent(ctx context.Context, arg InsertFilmEventParams) error {
	_, err := q.db.Exec(ctx, insertFilmEvent,
		arg.Name,
		arg.Url,
		arg.StartDate,
		arg.EndDate,
		arg.LocationName,
		arg.LocationAddress,
		arg.OrganizerName,
		arg.OrganizerUrl,
		arg.PerformerName,
	)
	return err
}

const insertUser = `-- name: InsertUser :exec
INSERT INTO "user" (email, letterboxd_username, token) VALUES ($1, $2, $3)
`

type InsertUserParams struct {
	Email              string `json:"email"`
	LetterboxdUsername string `json:"letterboxd_username"`
	Token              string `json:"token"`
}

func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) error {
	_, err := q.db.Exec(ctx, insertUser, arg.Email, arg.LetterboxdUsername, arg.Token)
	return err
}

const updateUserEmailConfirmation = `-- name: UpdateUserEmailConfirmation :exec
UPDATE "user"
SET email_confirmation = $1
WHERE id = $2
`

type UpdateUserEmailConfirmationParams struct {
	EmailConfirmation bool  `json:"email_confirmation"`
	ID                int64 `json:"id"`
}

func (q *Queries) UpdateUserEmailConfirmation(ctx context.Context, arg UpdateUserEmailConfirmationParams) error {
	_, err := q.db.Exec(ctx, updateUserEmailConfirmation, arg.EmailConfirmation, arg.ID)
	return err
}

const updateUserWatchlist = `-- name: UpdateUserWatchlist :exec
UPDATE "user" 
SET watchlist = $2 
WHERE email = $1
`

type UpdateUserWatchlistParams struct {
	Email     string   `json:"email"`
	Watchlist []string `json:"watchlist"`
}

func (q *Queries) UpdateUserWatchlist(ctx context.Context, arg UpdateUserWatchlistParams) error {
	_, err := q.db.Exec(ctx, updateUserWatchlist, arg.Email, arg.Watchlist)
	return err
}
