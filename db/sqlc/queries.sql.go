// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package db

import (
	"context"
	"time"
)

const deleteUserWatchlist = `-- name: DeleteUserWatchlist :exec
DELETE FROM watchlist WHERE user_id = ?
`

func (q *Queries) DeleteUserWatchlist(ctx context.Context, userID int64) error {
	_, err := q.db.ExecContext(ctx, deleteUserWatchlist, userID)
	return err
}

const getAllUsers = `-- name: GetAllUsers :many
SELECT email, letterboxd_username FROM user
`

type GetAllUsersRow struct {
	Email              string `json:"email"`
	LetterboxdUsername string `json:"letterboxd_username"`
}

func (q *Queries) GetAllUsers(ctx context.Context) ([]GetAllUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllUsersRow{}
	for rows.Next() {
		var i GetAllUsersRow
		if err := rows.Scan(&i.Email, &i.LetterboxdUsername); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchingFilmEventsByEmail = `-- name: GetMatchingFilmEventsByEmail :many
SELECT fe.name, fe.url, fe.start_date, fe.end_date,
       fe.location_name, fe.location_address,
       fe.organizer_name, fe.organizer_url, fe.performer_name
FROM film_event AS fe
INNER JOIN watchlist AS wl ON fe.name = wl.film_title
INNER JOIN user ON user.id = wl.user_id
WHERE user.email = ?
`

type GetMatchingFilmEventsByEmailRow struct {
	Name            string    `json:"name"`
	Url             string    `json:"url"`
	StartDate       time.Time `json:"start_date"`
	EndDate         time.Time `json:"end_date"`
	LocationName    string    `json:"location_name"`
	LocationAddress string    `json:"location_address"`
	OrganizerName   string    `json:"organizer_name"`
	OrganizerUrl    string    `json:"organizer_url"`
	PerformerName   string    `json:"performer_name"`
}

func (q *Queries) GetMatchingFilmEventsByEmail(ctx context.Context, email string) ([]GetMatchingFilmEventsByEmailRow, error) {
	rows, err := q.db.QueryContext(ctx, getMatchingFilmEventsByEmail, email)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMatchingFilmEventsByEmailRow{}
	for rows.Next() {
		var i GetMatchingFilmEventsByEmailRow
		if err := rows.Scan(
			&i.Name,
			&i.Url,
			&i.StartDate,
			&i.EndDate,
			&i.LocationName,
			&i.LocationAddress,
			&i.OrganizerName,
			&i.OrganizerUrl,
			&i.PerformerName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrCreateUserID = `-- name: GetOrCreateUserID :one
SELECT id FROM user WHERE email = ?
`

func (q *Queries) GetOrCreateUserID(ctx context.Context, email string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getOrCreateUserID, email)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertFilmEvent = `-- name: InsertFilmEvent :exec
INSERT INTO film_event (
    name, url, start_date, end_date,
    location_name, location_address,
    organizer_name, organizer_url, performer_name
) VALUES (
    ?, ?, ?, ?,
    ?, ?, ?, ?, ?
)
`

type InsertFilmEventParams struct {
	Name            string    `json:"name"`
	Url             string    `json:"url"`
	StartDate       time.Time `json:"start_date"`
	EndDate         time.Time `json:"end_date"`
	LocationName    string    `json:"location_name"`
	LocationAddress string    `json:"location_address"`
	OrganizerName   string    `json:"organizer_name"`
	OrganizerUrl    string    `json:"organizer_url"`
	PerformerName   string    `json:"performer_name"`
}

func (q *Queries) InsertFilmEvent(ctx context.Context, arg InsertFilmEventParams) error {
	_, err := q.db.ExecContext(ctx, insertFilmEvent,
		arg.Name,
		arg.Url,
		arg.StartDate,
		arg.EndDate,
		arg.LocationName,
		arg.LocationAddress,
		arg.OrganizerName,
		arg.OrganizerUrl,
		arg.PerformerName,
	)
	return err
}

const insertUser = `-- name: InsertUser :exec
INSERT INTO user (email, letterboxd_username) VALUES (?, ?)
`

type InsertUserParams struct {
	Email              string `json:"email"`
	LetterboxdUsername string `json:"letterboxd_username"`
}

func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) error {
	_, err := q.db.ExecContext(ctx, insertUser, arg.Email, arg.LetterboxdUsername)
	return err
}

const insertWatchlistItem = `-- name: InsertWatchlistItem :exec
INSERT INTO watchlist (user_id, film_title) VALUES (?, ?)
`

type InsertWatchlistItemParams struct {
	UserID    int64  `json:"user_id"`
	FilmTitle string `json:"film_title"`
}

func (q *Queries) InsertWatchlistItem(ctx context.Context, arg InsertWatchlistItemParams) error {
	_, err := q.db.ExecContext(ctx, insertWatchlistItem, arg.UserID, arg.FilmTitle)
	return err
}
